<?php

namespace App\Providers;

use App\Events\PodcastProcessed;
use Illuminate\Auth\Events\Registered;
use Illuminate\Auth\Events\Verified;
use Illuminate\Auth\Listeners\SendEmailVerificationNotification;
use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Event;

class EventServiceProvider extends ServiceProvider
{
    /**
     * The event listener mappings for the application.
     * The listen property contains an array of all events (keys) and their listeners (values).
     * You may add as many events to this array as your application requires.
     *
     * @var array
     */
    protected $listen = [
        Registered::class => [
            SendEmailVerificationNotification::class,
        ],

        // Laravel dispatches events during the email verification process.
        // You may attach listeners to these events in your EventServiceProvider:
        Verified::class => [
            'App\Listeners\LogVerifiedUser',
        ],
        'App\Events\OrderShipped' =>
            [
                'App\Listeners\SendShipmentNotification',
            ],
        'Illuminate\Notifications\Events\NotificationSent' => [
            'App\Listeners\LogNotification',
        ]

    ];

    /**
     * After writing the subscriber, you are ready to register it with the event dispatcher.
     * You may register subscribers using the $subscribe property on the EventServiceProvider.
     * For example, let's add the UserEventSubscriber to the list:
     * @var array
     */
    protected $subscribe = [
        'App\Listeners\UserEventSubscriber',
    ];

    /**
     * Register any events for your application.
     *
     * @return void
     */
    public function boot()
    {
        parent::boot();


//        // Typically, events should be registered via the EventServiceProvider $listen array;
//        // however, you may also register Closure based events manually in the boot method of your EventServiceProvider:
//        Event::listen(function (PodcastProcessed $event) {
//            //
//        });
//        //
//
//        // When registering event listeners manually,
//        // you may wrap the listener Closure within the Illuminate\Events\queueable function to instruct Laravel
//        // to execute the listener using the queue:
//        Event::listen(\Illuminate\Events\queueable(function (PodcastProcessed $event) {
//            //
//        }));
//
//
//        Event::listen(queueable(function (PodcastProcessed $event) {
//            //
//        })
//            // Like queued jobs, you may use the onConnection, onQueue, and delay methods to
//            // customize the execution of the queued listener:
//            ->onConnection('redis')
//            ->onQueue('podcasts')
//            ->delay(now()->addSeconds(10))
//
//
//            // If you would like to handle anonymous queued listener failures,
//            // you may provide a Closure to the catch method while defining the queueable listener:
//            ->catch(function (PodcastProcessed $event, Throwable $e) {
//                // The queued listener failed...
//            }));


        // You may even register listeners using the * as a wildcard parameter,
        // allowing you to catch multiple events on the same listener.
        // Wildcard listeners receive the event name as their first argument,
        // and the entire event data array as their second argument:

        Event::listen('event.*', function ($eventName, array $data) {
            //
        });

    }

    /**
     * Event discovery is disabled by default,
     * but you can enable it by overriding the shouldDiscoverEvents
     * method of your application's EventServiceProvider:
     *
     * Determine if events and listeners should be automatically discovered.
     * @return bool
     */
    public function shouldDiscoverEvents()
    {
        return true;
    }


    /**
     * By default, all listeners within your application's Listeners directory will be scanned.
     * If you would like to define additional directories to scan,
     * you may override the discoverEventsWithin method in your EventServiceProvider:
     * @return array
     */
    protected function discoverEventsWithin()
    {
        return [
            $this->app->path('Listeners'),
        ];
//        return parent::discoverEventsWithin(); // TODO: Change the autogenerated stub
    }
}
